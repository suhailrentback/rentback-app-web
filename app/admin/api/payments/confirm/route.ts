// app/admin/api/payments/confirm/route.ts
import { NextResponse } from "next/server";
import { cookies } from "next/headers";
import { createServerClient } from "@supabase/ssr";
import PDFDocument from "pdfkit";

const SUPABASE_URL = process.env.NEXT_PUBLIC_SUPABASE_URL!;
const SUPABASE_ANON = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!;

// Optional email (no-op if missing)
const RESEND_API_KEY = process.env.RESEND_API_KEY || "";
const RESEND_FROM = process.env.RESEND_FROM || "";

function createSbFromCookies() {
  const jar = cookies();
  return createServerClient(SUPABASE_URL, SUPABASE_ANON, {
    cookies: {
      get: (n: string) => jar.get(n)?.value,
      set() {},
      remove() {},
    },
  });
}

async function getPaymentWithInvoice(sb: ReturnType<typeof createSbFromCookies>, id: string) {
  const { data, error } = await sb
    .from("payments")
    .select(
      `
      id, amount_cents, currency, status, reference, created_at, confirmed_at, tenant_id,
      invoice:invoices ( id, number, landlord_id, due_date, description )
    `
    )
    .eq("id", id)
    .single();
  if (error) throw new Error(`load_payment_failed: ${error.message}`);
  if (!data) throw new Error("payment_not_found");
  return data as any;
}

async function upsertConfirm(sb: ReturnType<typeof createSbFromCookies>, paymentId: string) {
  const now = new Date().toISOString();
  const { data: updated, error: upErr } = await sb
    .from("payments")
    .update({ status: "CONFIRMED", confirmed_at: now })
    .eq("id", paymentId)
    .select()
    .single();
  if (upErr) throw new Error(`confirm_failed: ${upErr.message}`);
  return updated as any;
}

async function insertReceipt(sb: ReturnType<typeof createSbFromCookies>, invoiceId: string, paymentId: string) {
  const { data, error } = await sb
    .from("receipts")
    .insert({ invoice_id: invoiceId, payment_id: paymentId })
    .select()
    .single();
  if (error) throw new Error(`receipt_insert_failed: ${error.message}`);
  return data as any;
}

async function getTenantEmail(sb: ReturnType<typeof createSbFromCookies>, tenantId: string) {
  const { data, error } = await sb.from("profiles").select("email, full_name").eq("id", tenantId).single();
  if (error) throw new Error(`load_tenant_failed: ${error.message}`);
  return data as { email: string; full_name: string | null };
}

function money(cents: number, curr: string) {
  const v = (cents ?? 0) / 100;
  try {
    return new Intl.NumberFormat(undefined, { style: "currency", currency: curr || "PKR" }).format(v);
  } catch {
    return `${v.toFixed(2)} ${curr || ""}`.trim();
  }
}

async function buildReceiptPdfBytes(opts: {
  tenantName?: string | null;
  invoiceNumber: string | number;
  amountCents: number;
  currency: string;
  reference?: string | null;
  confirmedAt?: string | null;
}) {
  const doc = new PDFDocument({ size: "A4", margin: 56 });
  const chunks: Buffer[] = [];
  return await new Promise<Buffer>((resolve) => {
    doc.on("data", (c) => chunks.push(Buffer.isBuffer(c) ? c : Buffer.from(c)));
    doc.on("end", () => resolve(Buffer.concat(chunks)));

    doc.fontSize(18).text("RentBack — Payment Receipt", { align: "left" });
    doc.moveDown(0.5);
    doc.fontSize(10).fillColor("#666").text("Thank you! This is your official receipt.", { align: "left" });
    doc.moveDown(1);
    doc.fillColor("#000");

    const lines = [
      ["Invoice", String(opts.invoiceNumber)],
      ["Amount", money(opts.amountCents ?? 0, (opts.currency || "PKR").toUpperCase())],
      ["Reference", opts.reference || "—"],
      ["Confirmed at", opts.confirmedAt ? new Date(opts.confirmedAt).toLocaleString() : "—"],
      ["Billed to", opts.tenantName || "Tenant"],
    ];
    lines.forEach(([k, v]) => {
      doc.fontSize(11).text(`${k}:`, { continued: true }).font("Helvetica-Bold").text(` ${v}`).font("Helvetica");
    });

    doc.moveDown(2);
    doc.fontSize(9).fillColor("#555").text("Generated by RentBack.");
    doc.end();
  });
}

async function maybeSendEmailWithAttachment(args: {
  to: string;
  subject: string;
  html: string;
  text: string;
  pdfFilename: string;
  pdfBytes: Buffer;
}) {
  if (!RESEND_API_KEY || !RESEND_FROM) return { ok: false as const, reason: "no_email_keys" };

  const base64 = args.pdfBytes.toString("base64");
  const payload = {
    from: RESEND_FROM,
    to: [args.to],
    subject: args.subject,
    html: args.html,
    text: args.text,
    attachments: [
      {
        filename: args.pdfFilename,
        content: base64,
        contentType: "application/pdf",
      },
    ],
  };

  const r = await fetch("https://api.resend.com/emails", {
    method: "POST",
    headers: { Authorization: `Bearer ${RESEND_API_KEY}`, "Content-Type": "application/json" },
    body: JSON.stringify(payload),
  });

  if (!r.ok) {
    const body = await r.text();
    return { ok: false as const, reason: `resend_failed: ${r.status} ${body}` };
  }
  return { ok: true as const };
}

async function getPaymentId(req: Request): Promise<string | null> {
  const ct = req.headers.get("content-type") || "";
  if (ct.includes("application/x-www-form-urlencoded") || ct.includes("multipart/form-data")) {
    const form = await req.formData();
    const v = form.get("paymentId") || form.get("id");
    if (typeof v === "string" && v) return v;
  }
  if (ct.includes("application/json")) {
    const js = await req.json().catch(() => null);
    const v = js?.paymentId || js?.id;
    if (typeof v === "string" && v) return v;
  }
  const url = new URL(req.url);
  const qp = url.searchParams.get("paymentId") || url.searchParams.get("id");
  return typeof qp === "string" && qp ? qp : null;
}

export async function POST(req: Request) {
  try {
    const id = await getPaymentId(req);
    if (!id) return NextResponse.json({ error: "missing_payment_id" }, { status: 400 });

    const sb = createSbFromCookies();

    const payment = await getPaymentWithInvoice(sb, id);
    const invoice = Array.isArray(payment.invoice) ? payment.invoice[0] : payment.invoice;
    if (!invoice?.id) return NextResponse.json({ error: "invoice_not_found" }, { status: 400 });

    // Confirm + receipt
    const confirmed = await upsertConfirm(sb, payment.id);
    const receipt = await insertReceipt(sb, invoice.id, payment.id);

    // Email (best-effort)
    const tenant = await getTenantEmail(sb, confirmed.tenant_id);
    const pdf = await buildReceiptPdfBytes({
      tenantName: tenant.full_name || tenant.email,
      invoiceNumber: invoice.number,
      amountCents: confirmed.amount_cents,
      currency: (confirmed.currency || "PKR").toUpperCase(),
      reference: confirmed.reference,
      confirmedAt: confirmed.confirmed_at,
    });

    const subject = `RentBack Receipt — Invoice ${invoice.number}`;
    const text = `Hi ${tenant.full_name || "there"},\n\nPayment received. Your receipt is attached.\n\nInvoice: ${invoice.number}\nAmount: ${money(
      confirmed.amount_cents,
      confirmed.currency || "PKR"
    )}\nReference: ${confirmed.reference || "-"}\n\nThank you,\nRentBack`;
    const html = `<p>Hi ${tenant.full_name || "there"},</p>
<p>Payment received. Your receipt is attached.</p>
<ul>
<li><b>Invoice:</b> ${invoice.number}</li>
<li><b>Amount:</b> ${money(confirmed.amount_cents, confirmed.currency || "PKR")}</li>
<li><b>Reference:</b> ${confirmed.reference || "-"}</li>
</ul>
<p>Thank you,<br/>RentBack</p>`;

    await maybeSendEmailWithAttachment({
      to: tenant.email,
      subject,
      html,
      text,
      pdfFilename: `receipt-${invoice.number}.pdf`,
      pdfBytes: pdf,
    });

    // Done → back to admin/payments
    const back = new URL("/admin/payments?confirmed=1", req.url);
    return NextResponse.redirect(back, 303);
  } catch (e: any) {
    return NextResponse.json({ error: String(e?.message || e) }, { status: 500 });
  }
}
